<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>IDL-Grouplib: groupstuff.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>groupstuff.c</h1><a href="groupstuff_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00002 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00003 
00004 <span class="preprocessor">#include "<a class="code" href="groupstuff_8h.html">groupstuff.h</a>"</span>
00005 
<a name="l00019"></a><a class="code" href="structIDL__STRING.html">00019</a> <span class="keyword">typedef</span> <span class="keyword">struct</span>
00020 <span class="keyword"></span>{
<a name="l00021"></a><a class="code" href="structIDL__STRING.html#o0">00021</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> slen;
<a name="l00022"></a><a class="code" href="structIDL__STRING.html#o1">00022</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stype;
<a name="l00023"></a><a class="code" href="structIDL__STRING.html#o2">00023</a>   <span class="keywordtype">char</span> *s;
00024 }
00025 <a class="code" href="structIDL__STRING.html">IDL_STRING</a>;
00026 
00027 
<a name="l00028"></a><a class="code" href="structio__header.html">00028</a> <span class="keyword">typedef</span> <span class="keyword">struct</span>
00029 <span class="keyword"></span>{
<a name="l00030"></a><a class="code" href="structio__header.html#o0">00030</a>   <span class="keywordtype">int</span> npart[6];
<a name="l00031"></a><a class="code" href="structio__header.html#o1">00031</a>   <span class="keywordtype">double</span> mass[6];
<a name="l00032"></a><a class="code" href="structio__header.html#o2">00032</a>   <span class="keywordtype">double</span> time;
<a name="l00033"></a><a class="code" href="structio__header.html#o3">00033</a>   <span class="keywordtype">double</span> redshift;
<a name="l00034"></a><a class="code" href="structio__header.html#o4">00034</a>   <span class="keywordtype">int</span> flag_sfr;
<a name="l00035"></a><a class="code" href="structio__header.html#o5">00035</a>   <span class="keywordtype">int</span> flag_feedback;
<a name="l00036"></a><a class="code" href="structio__header.html#o6">00036</a>   <span class="keywordtype">int</span> npartTotal[6];
<a name="l00037"></a><a class="code" href="structio__header.html#o7">00037</a>   <span class="keywordtype">int</span> flag_cooling;
<a name="l00038"></a><a class="code" href="structio__header.html#o8">00038</a>   <span class="keywordtype">int</span> num_files;
<a name="l00039"></a><a class="code" href="structio__header.html#o9">00039</a>   <span class="keywordtype">double</span> BoxSize;
<a name="l00040"></a><a class="code" href="structio__header.html#o10">00040</a>   <span class="keywordtype">double</span> Omega0;
<a name="l00041"></a><a class="code" href="structio__header.html#o11">00041</a>   <span class="keywordtype">double</span> OmegaLambda;
<a name="l00042"></a><a class="code" href="structio__header.html#o12">00042</a>   <span class="keywordtype">double</span> HubbleParam;
<a name="l00043"></a><a class="code" href="structio__header.html#o13">00043</a>   <span class="keywordtype">int</span> flag_stellarage;
<a name="l00044"></a><a class="code" href="structio__header.html#o14">00044</a>   <span class="keywordtype">int</span> flag_metals;
<a name="l00045"></a><a class="code" href="structio__header.html#o15">00045</a>   <span class="keywordtype">int</span> hashtabsize;
<a name="l00046"></a><a class="code" href="structio__header.html#o16">00046</a>   <span class="keywordtype">char</span> fill[84];                <span class="comment">/* fills to 256 Bytes */</span>
00047 }
00048 <a class="code" href="structio__header.html">io_header</a>;
00049 
00050 
00051 
<a name="l00052"></a><a class="code" href="structcat__data.html">00052</a> <span class="keyword">typedef</span> <span class="keyword">struct</span>
00053 <span class="keyword"></span>{
<a name="l00054"></a><a class="code" href="structcat__data.html#o0">00054</a>   <span class="keywordtype">int</span> len;
<a name="l00055"></a><a class="code" href="structcat__data.html#o1">00055</a>   <span class="keywordtype">int</span> file;
<a name="l00056"></a><a class="code" href="structcat__data.html#o2">00056</a>   <span class="keywordtype">int</span> offset;
00057 }
00058 <a class="code" href="structcat__data.html">cat_data</a>;
00059 
00060 
00061 
00062 
00063 
00064 <span class="keyword">static</span> <span class="keywordtype">double</span> BoxSize;
00065 
00066 <span class="comment">/*  Expected input values:</span>
00067 <span class="comment"> *  char*    Output directory</span>
00068 <span class="comment"> *  int      snapshot number</span>
00069 <span class="comment"> */</span>
<a name="l00070"></a><a class="code" href="groupstuff_8h.html#a3">00070</a> <span class="keywordtype">int</span> <a class="code" href="groupstuff_8h.html#a3">get_total_number_of_groups</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">void</span> *argv[])
00071 {
00072   <span class="keywordtype">int</span> Ngroups, Nids, TotNgroups, NTask, Num;
00073   <a class="code" href="structIDL__STRING.html">IDL_STRING</a> *idl_s;
00074   <span class="keywordtype">char</span> *OutputDir;
00075   <span class="keywordtype">char</span> buf[1000];
00076   FILE *fd;
00077 
00078   idl_s = (<a class="code" href="structIDL__STRING.html">IDL_STRING</a> *) argv[0];
00079   OutputDir = idl_s-&gt;<a class="code" href="structIDL__STRING.html#o2">s</a>;
00080   Num = *(<span class="keywordtype">int</span> *) argv[1];
00081 
00082   sprintf(buf, <span class="stringliteral">"%s/group_tab_%03d.0"</span>, OutputDir, Num);
00083   <span class="keywordflow">if</span>(!(fd = fopen(buf, <span class="stringliteral">"r"</span>)))
00084     {
00085       printf(<span class="stringliteral">"can't open file `%s'\n"</span>, buf);
00086       <span class="keywordflow">return</span> -1;
00087     }
00088 
00089   fread(&amp;Ngroups, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00090   fread(&amp;Nids, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00091   fread(&amp;TotNgroups, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00092   fread(&amp;NTask, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00093   fclose(fd);
00094 
00095   <span class="keywordflow">return</span> TotNgroups;
00096 }
00097 
00098 
<a name="l00099"></a><a class="code" href="groupstuff_8h.html#a8">00099</a> <span class="keywordtype">int</span> <a class="code" href="groupstuff_8h.html#a8">get_minimum_group_len</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">void</span> *argv[])
00100 {
00101   <span class="keywordtype">int</span> Ngroups, Nids, TotNgroups, NTask, Num, GroupMinLen;
00102   <a class="code" href="structIDL__STRING.html">IDL_STRING</a> *idl_s;
00103   <span class="keywordtype">char</span> *OutputDir;
00104   <span class="keywordtype">char</span> buf[1000];
00105   FILE *fd;
00106 
00107   idl_s = (<a class="code" href="structIDL__STRING.html">IDL_STRING</a> *) argv[0];
00108   OutputDir = idl_s-&gt;<a class="code" href="structIDL__STRING.html#o2">s</a>;
00109   Num = *(<span class="keywordtype">int</span> *) argv[1];
00110 
00111   sprintf(buf, <span class="stringliteral">"%s/group_tab_%03d.0"</span>, OutputDir, Num);
00112   <span class="keywordflow">if</span>(!(fd = fopen(buf, <span class="stringliteral">"r"</span>)))
00113     {
00114       printf(<span class="stringliteral">"can't open file `%s'\n"</span>, buf);
00115       <span class="keywordflow">return</span> -1;
00116     }
00117 
00118   fread(&amp;Ngroups, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00119   fread(&amp;Nids, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00120   fread(&amp;TotNgroups, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00121   fread(&amp;NTask, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00122   fseek(fd, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>) * Ngroups, SEEK_CUR);   <span class="comment">/* skip GroupLen */</span>
00123   fseek(fd, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>) * Ngroups, SEEK_CUR);   <span class="comment">/* skip GroupOffset */</span>
00124   fread(&amp;GroupMinLen, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00125   fclose(fd);
00126 
00127   <span class="keywordflow">return</span> GroupMinLen;
00128 }
00129 
00130 
00131 
<a name="l00132"></a><a class="code" href="groupstuff_8h.html#a9">00132</a> <span class="keywordtype">int</span> <a class="code" href="groupstuff_8h.html#a9">get_groupcount_below_minimum_len</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">void</span> *argv[])
00133 {
00134   <span class="keywordtype">int</span> Ngroups, Nids, TotNgroups, NTask, Num, i, filenr, GroupMinLen;
00135   <span class="keywordtype">int</span> *count;
00136   <span class="keywordtype">double</span> *CountBelowMinLen;
00137   <span class="keywordtype">double</span> *countIDs;
00138   <span class="keywordtype">long</span> <span class="keywordtype">long</span> totIds;
00139   <a class="code" href="structIDL__STRING.html">IDL_STRING</a> *idl_s;
00140   <span class="keywordtype">char</span> *OutputDir;
00141   <span class="keywordtype">char</span> buf[1000];
00142   FILE *fd;
00143 
00144   idl_s = (<a class="code" href="structIDL__STRING.html">IDL_STRING</a> *) argv[0];
00145   OutputDir = idl_s-&gt;<a class="code" href="structIDL__STRING.html#o2">s</a>;
00146   Num = *(<span class="keywordtype">int</span> *) argv[1];
00147 
00148   CountBelowMinLen = (<span class="keywordtype">double</span> *) argv[2];
00149 
00150   countIDs = (<span class="keywordtype">double</span> *) argv[3];
00151 
00152   sprintf(buf, <span class="stringliteral">"%s/group_tab_%03d.0"</span>, OutputDir, Num);
00153   <span class="keywordflow">if</span>(!(fd = fopen(buf, <span class="stringliteral">"r"</span>)))
00154     {
00155       printf(<span class="stringliteral">"can't open file `%s'\n"</span>, buf);
00156       <span class="keywordflow">return</span> -1;
00157     }
00158 
00159   fread(&amp;Ngroups, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00160   fread(&amp;Nids, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00161   fread(&amp;TotNgroups, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00162   fread(&amp;NTask, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00163   fseek(fd, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>) * Ngroups, SEEK_CUR);   <span class="comment">/* skip GroupLen */</span>
00164   fseek(fd, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>) * Ngroups, SEEK_CUR);   <span class="comment">/* skip GroupOffset */</span>
00165   fread(&amp;GroupMinLen, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00166   fclose(fd);
00167 
00168 
00169   count = malloc(GroupMinLen * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00170 
00171   <span class="keywordflow">for</span>(i = 0; i &lt; GroupMinLen; i++)
00172     CountBelowMinLen[i] = 0;
00173 
00174   totIds = 0;
00175 
00176   <span class="keywordflow">for</span>(filenr = 0; filenr &lt; NTask; filenr++)
00177     {
00178       sprintf(buf, <span class="stringliteral">"%s/group_tab_%03d.%d"</span>, OutputDir, Num, filenr);
00179       <span class="keywordflow">if</span>(!(fd = fopen(buf, <span class="stringliteral">"r"</span>)))
00180         {
00181           printf(<span class="stringliteral">"can't open file `%s'\n"</span>, buf);
00182           <span class="keywordflow">return</span> -1;
00183         }
00184 
00185       fread(&amp;Ngroups, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00186       fread(&amp;Nids, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00187       fread(&amp;TotNgroups, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00188       fread(&amp;NTask, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00189       fseek(fd, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>) * Ngroups, SEEK_CUR);       <span class="comment">/* skip GroupLen */</span>
00190       fseek(fd, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>) * Ngroups, SEEK_CUR);       <span class="comment">/* skip GroupOffset */</span>
00191       fread(&amp;GroupMinLen, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00192       fread(count, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), GroupMinLen, fd);
00193 
00194       totIds += Nids;
00195 
00196       <span class="keywordflow">for</span>(i = 0; i &lt; GroupMinLen; i++)
00197         CountBelowMinLen[i] += count[i];
00198 
00199       fclose(fd);
00200     }
00201 
00202   free(count);
00203 
00204   *countIDs = (double)(totIds);
00205 
00206   <span class="keywordflow">return</span> GroupMinLen;
00207 }
00208 
00209 
00210 
00211 
00212 
00213 
00214 
<a name="l00215"></a><a class="code" href="groupstuff_8h.html#a4">00215</a> <span class="keywordtype">int</span> <a class="code" href="groupstuff_8h.html#a4">get_group_catalogue</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">void</span> *argv[])
00216 {
00217   <span class="keywordtype">int</span> Ngroups, Nids, TotNgroups, NTask, Num, count, i, filenr;
00218   <span class="keywordtype">int</span> *GroupLen, *GroupFileNr, *GroupNr;
00219   <a class="code" href="structIDL__STRING.html">IDL_STRING</a> *idl_s;
00220   <a class="code" href="structcat__data.html">cat_data</a> *temp;
00221   <span class="keywordtype">char</span> *OutputDir;
00222   <span class="keywordtype">char</span> buf[1000];
00223   FILE *fd;
00224 
00225   idl_s = (<a class="code" href="structIDL__STRING.html">IDL_STRING</a> *) argv[0];
00226   OutputDir = idl_s-&gt;<a class="code" href="structIDL__STRING.html#o2">s</a>;
00227   Num = *(<span class="keywordtype">int</span> *) argv[1];
00228 
00229   GroupLen = (<span class="keywordtype">int</span> *) argv[2];
00230   GroupFileNr = (<span class="keywordtype">int</span> *) argv[3];
00231   GroupNr = (<span class="keywordtype">int</span> *) argv[4];
00232 
00233   sprintf(buf, <span class="stringliteral">"%s/group_tab_%03d.0"</span>, OutputDir, Num);
00234   <span class="keywordflow">if</span>(!(fd = fopen(buf, <span class="stringliteral">"r"</span>)))
00235     {
00236       printf(<span class="stringliteral">"can't open file `%s'\n"</span>, buf);
00237       <span class="keywordflow">return</span> -1;
00238     }
00239 
00240   fread(&amp;Ngroups, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00241   fread(&amp;Nids, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00242   fread(&amp;TotNgroups, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00243   fread(&amp;NTask, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00244   fclose(fd);
00245 
00246 
00247   <span class="keywordflow">for</span>(filenr = 0, count = 0; filenr &lt; NTask; filenr++)
00248     {
00249       sprintf(buf, <span class="stringliteral">"%s/group_tab_%03d.%d"</span>, OutputDir, Num, filenr);
00250       <span class="keywordflow">if</span>(!(fd = fopen(buf, <span class="stringliteral">"r"</span>)))
00251         {
00252           printf(<span class="stringliteral">"can't open file `%s'\n"</span>, buf);
00253           <span class="keywordflow">return</span> -1;
00254         }
00255 
00256       fread(&amp;Ngroups, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00257       fread(&amp;Nids, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00258       fread(&amp;TotNgroups, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00259       fread(&amp;NTask, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00260 
00261       fread(&amp;GroupLen[count], <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), Ngroups, fd);
00262 
00263       <span class="keywordflow">for</span>(i = 0; i &lt; Ngroups; i++)
00264         {
00265           GroupFileNr[i + count] = filenr;
00266           GroupNr[i + count] = i;
00267         }
00268 
00269       count += Ngroups;
00270 
00271       fclose(fd);
00272     }
00273 
00274   temp = malloc(<span class="keyword">sizeof</span>(<a class="code" href="structcat__data.html">cat_data</a>) * TotNgroups);
00275 
00276   <span class="keywordflow">for</span>(i = 0; i &lt; TotNgroups; i++)
00277     {
00278       temp[i].<a class="code" href="structcat__data.html#o0">len</a> = GroupLen[i];
00279       temp[i].<a class="code" href="structcat__data.html#o1">file</a> = GroupFileNr[i];
00280       temp[i].<a class="code" href="structcat__data.html#o2">offset</a> = GroupNr[i];
00281     }
00282 
00283   qsort(temp, TotNgroups, <span class="keyword">sizeof</span>(cat_data), <a class="code" href="groupstuff_8c.html#a15">id_sort_groups</a>);
00284 
00285   <span class="keywordflow">for</span>(i = 0; i &lt; TotNgroups; i++)
00286     {
00287       GroupLen[i] = temp[i].<a class="code" href="structcat__data.html#o0">len</a>;
00288       GroupFileNr[i] = temp[i].<a class="code" href="structcat__data.html#o1">file</a>;
00289       GroupNr[i] = temp[i].<a class="code" href="structcat__data.html#o2">offset</a>;
00290     }
00291 
00292   free(temp);
00293 
00294   <span class="keywordflow">return</span> TotNgroups;
00295 }
00296 
<a name="l00297"></a><a class="code" href="groupstuff_8h.html#a11">00297</a> <span class="keywordtype">int</span> <a class="code" href="groupstuff_8h.html#a11">id_sort_groups</a>(<span class="keyword">const</span> <span class="keywordtype">void</span> *a, <span class="keyword">const</span> <span class="keywordtype">void</span> *b)
00298 {
00299   <span class="keywordflow">if</span>(((<a class="code" href="structcat__data.html">cat_data</a> *) a)-&gt;len &gt; ((<a class="code" href="structcat__data.html">cat_data</a> *) b)-&gt;len)
00300     <span class="keywordflow">return</span> -1;
00301 
00302   <span class="keywordflow">if</span>(((<a class="code" href="structcat__data.html">cat_data</a> *) a)-&gt;len &lt; ((<a class="code" href="structcat__data.html">cat_data</a> *) b)-&gt;len)
00303     <span class="keywordflow">return</span> +1;
00304 
00305   <span class="keywordflow">return</span> 0;
00306 }
00307 
00308 
<a name="l00309"></a><a class="code" href="groupstuff_8h.html#a6">00309</a> <span class="keywordtype">int</span> <a class="code" href="groupstuff_8h.html#a6">get_hash_table_size</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">void</span> *argv[])
00310 {
00311   <span class="keywordtype">int</span> Num, dummy;
00312   <span class="keywordtype">int</span> *NFiles;
00313   <a class="code" href="structio__header.html">io_header</a> header;
00314   <a class="code" href="structIDL__STRING.html">IDL_STRING</a> *idl_s;
00315   <span class="keywordtype">char</span> *OutputDir, *Snapbase;
00316   <span class="keywordtype">char</span> buf[1000];
00317   FILE *fd;
00318 
00319   idl_s = (<a class="code" href="structIDL__STRING.html">IDL_STRING</a> *) argv[0];
00320   OutputDir = idl_s-&gt;<a class="code" href="structIDL__STRING.html#o2">s</a>;
00321   Num = *(<span class="keywordtype">int</span> *) argv[1];
00322   idl_s = (<a class="code" href="structIDL__STRING.html">IDL_STRING</a> *) argv[2];
00323   Snapbase = idl_s-&gt;<a class="code" href="structIDL__STRING.html#o2">s</a>;
00324 
00325   NFiles = (<span class="keywordtype">int</span> *) argv[3];
00326 
00327   sprintf(buf, <span class="stringliteral">"%s/%s_%03d.0"</span>, OutputDir, Snapbase, Num);
00328   <span class="keywordflow">if</span>(!(fd = fopen(buf, <span class="stringliteral">"r"</span>)))
00329     {
00330       printf(<span class="stringliteral">"can't open file `%s'\n"</span>, buf);
00331       <span class="keywordflow">return</span> -1;
00332     }
00333 
00334   fread(&amp;dummy, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00335   printf(<span class="stringliteral">"dummy=%d\n"</span>, dummy);
00336 
00337   fread(&amp;header, <span class="keyword">sizeof</span>(<a class="code" href="structio__header.html">io_header</a>), 1, fd);
00338   fread(&amp;dummy, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00339 
00340   printf(<span class="stringliteral">"dummy=%d\n"</span>, dummy);
00341   fclose(fd);
00342 
00343   *NFiles = header.<a class="code" href="structio__header.html#o8">num_files</a>;
00344 
00345   <span class="keywordflow">return</span> header.<a class="code" href="structio__header.html#o15">hashtabsize</a>;
00346 }
00347 
00348 
<a name="l00349"></a><a class="code" href="groupstuff_8h.html#a5">00349</a> <span class="keywordtype">int</span> <a class="code" href="groupstuff_8h.html#a5">get_hash_table</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">void</span> *argv[])
00350 {
00351   <span class="keywordtype">int</span> Num, dummy, filenr, NTask;
00352   <span class="keywordtype">int</span> i, firstcell, lastcell;
00353   <a class="code" href="structio__header.html">io_header</a> header;
00354   <a class="code" href="structIDL__STRING.html">IDL_STRING</a> *idl_s;
00355   <span class="keywordtype">char</span> *OutputDir, *Snapbase;
00356   <span class="keywordtype">char</span> buf[1000];
00357   FILE *fd;
00358   <span class="keywordtype">int</span> *Hashtable;
00359   <span class="keywordtype">int</span> *Filetable;
00360   <span class="keywordtype">int</span> *LastHashCell;
00361   <span class="keywordtype">int</span> *NInFiles;
00362 
00363   idl_s = (<a class="code" href="structIDL__STRING.html">IDL_STRING</a> *) argv[0];
00364   OutputDir = idl_s-&gt;<a class="code" href="structIDL__STRING.html#o2">s</a>;
00365   Num = *(<span class="keywordtype">int</span> *) argv[1];
00366   idl_s = (<a class="code" href="structIDL__STRING.html">IDL_STRING</a> *) argv[2];
00367   Snapbase = idl_s-&gt;<a class="code" href="structIDL__STRING.html#o2">s</a>;
00368 
00369   Hashtable = (<span class="keywordtype">int</span> *) argv[3];
00370   Filetable = (<span class="keywordtype">int</span> *) argv[4];
00371   LastHashCell = (<span class="keywordtype">int</span> *) argv[5];
00372   NInFiles = (<span class="keywordtype">int</span> *) argv[6];
00373 
00374   NTask = 1;                    <span class="comment">/* will be taken from header */</span>
00375 
00376   <span class="keywordflow">for</span>(filenr = 0; filenr &lt; NTask; filenr++)
00377     {
00378       sprintf(buf, <span class="stringliteral">"%s/%s_%03d.%d"</span>, OutputDir, Snapbase, Num, filenr);
00379       <span class="keywordflow">if</span>(!(fd = fopen(buf, <span class="stringliteral">"r"</span>)))
00380         {
00381           printf(<span class="stringliteral">"can't open file `%s'\n"</span>, buf);
00382           <span class="keywordflow">return</span> -1;
00383         }
00384       fread(&amp;dummy, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00385       fread(&amp;header, <span class="keyword">sizeof</span>(<a class="code" href="structio__header.html">io_header</a>), 1, fd);
00386       fread(&amp;dummy, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00387       NTask = header.<a class="code" href="structio__header.html#o8">num_files</a>;
00388 
00389       <span class="comment">/* skip positions */</span>
00390       fread(&amp;dummy, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00391       fseek(fd, dummy, SEEK_CUR);
00392       fread(&amp;dummy, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00393 
00394       <span class="comment">/* skip velocities */</span>
00395       fread(&amp;dummy, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00396       fseek(fd, dummy, SEEK_CUR);
00397       fread(&amp;dummy, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00398 
00399       <span class="comment">/* skip IDs */</span>
00400       fread(&amp;dummy, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00401       fseek(fd, dummy, SEEK_CUR);
00402       fread(&amp;dummy, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00403 
00404       fread(&amp;dummy, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00405       fread(&amp;firstcell, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00406       fread(&amp;lastcell, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00407       fread(&amp;dummy, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00408 
00409       LastHashCell[filenr] = lastcell;
00410       NInFiles[filenr] = header.<a class="code" href="structio__header.html#o0">npart</a>[1];
00411 
00412       <span class="keywordflow">if</span>(firstcell &lt; 0 || firstcell &gt;= header.<a class="code" href="structio__header.html#o15">hashtabsize</a> || lastcell &lt; 0 || lastcell &gt;= header.<a class="code" href="structio__header.html#o15">hashtabsize</a>)
00413         {
00414           printf(<span class="stringliteral">"bummer!\n"</span>);
00415           <span class="keywordflow">return</span> -1;
00416         }
00417 
00418       fread(&amp;dummy, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00419       fread(&amp;Hashtable[firstcell], <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), lastcell - firstcell + 1, fd);
00420       fread(&amp;dummy, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00421 
00422       <span class="keywordflow">for</span>(i = 0; i &lt; lastcell - firstcell + 1; i++)
00423         Filetable[firstcell + i] = filenr;
00424 
00425       fclose(fd);
00426     }
00427 
00428   <span class="keywordflow">return</span> 0;
00429 }
00430 
00431 
00432 
00433 <span class="comment">/* determines the number of particles that would be </span>
00434 <span class="comment"> * in each file in case and equal volume decomposition is</span>
00435 <span class="comment"> * performed.</span>
00436 <span class="comment"> */</span>
<a name="l00437"></a><a class="code" href="groupstuff_8c.html#a18">00437</a> <span class="keywordtype">int</span> <a class="code" href="groupstuff_8c.html#a18">get_particles_in_cubes</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">void</span> *argv[])
00438 {
00439   <span class="keywordtype">int</span> Num;
00440   <a class="code" href="structIDL__STRING.html">IDL_STRING</a> *idl_s;
00441   <span class="keywordtype">char</span> *OutputDir, *Snapbase;
00442   <span class="keywordtype">int</span> *Hashtable, *LastHashCell;
00443   <span class="keywordtype">int</span> *Filetable, *NInFiles;
00444   <span class="keywordtype">int</span> NFiles;
00445   <span class="keywordtype">int</span> hashtabsize, count;
00446   <span class="keywordtype">int</span> hash_key, countsum, *TabCount, proc;
00447 
00448 
00449   idl_s = (<a class="code" href="structIDL__STRING.html">IDL_STRING</a> *) argv[0];
00450   OutputDir = idl_s-&gt;<a class="code" href="structIDL__STRING.html#o2">s</a>;
00451   Num = *(<span class="keywordtype">int</span> *) argv[1];
00452   idl_s = (<a class="code" href="structIDL__STRING.html">IDL_STRING</a> *) argv[2];
00453   Snapbase = idl_s-&gt;<a class="code" href="structIDL__STRING.html#o2">s</a>;
00454 
00455   Hashtable = (<span class="keywordtype">int</span> *) argv[3];
00456   Filetable = (<span class="keywordtype">int</span> *) argv[4];
00457   hashtabsize = *(<span class="keywordtype">int</span> *) argv[5];
00458   LastHashCell = (<span class="keywordtype">int</span> *) argv[6];
00459   NInFiles = (<span class="keywordtype">int</span> *) argv[7];
00460   NFiles =   *(<span class="keywordtype">int</span> *) argv[8];
00461   TabCount = (<span class="keywordtype">int</span> *) argv[9];
00462 
00463 
00464   <span class="keywordflow">for</span>(proc=0; proc &lt; NFiles; proc++)
00465     {
00466       countsum=0;
00467       <span class="keywordflow">for</span>(hash_key = proc*(hashtabsize/NFiles); hash_key &lt; (proc+1)*(hashtabsize/NFiles); hash_key++)
00468         {
00469           <span class="keywordflow">if</span>(hash_key != LastHashCell[Filetable[hash_key]])
00470             count = Hashtable[hash_key + 1] - Hashtable[hash_key];
00471           <span class="keywordflow">else</span>
00472             count = NInFiles[Filetable[hash_key]] - Hashtable[hash_key];
00473 
00474           countsum+=count;
00475         }
00476 
00477       TabCount[proc] = countsum;
00478     }
00479   
00480   <span class="keywordflow">return</span> 0;
00481 }
00482 
00483 
00484 
00485 
<a name="l00486"></a><a class="code" href="groupstuff_8h.html#a7">00486</a> <span class="keywordtype">int</span> <a class="code" href="groupstuff_8h.html#a7">get_group_coordinates</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">void</span> *argv[])
00487 {
00488   <span class="keywordtype">int</span> Num, dummy, NTask, ind;
00489   <span class="keywordtype">int</span> i, j, n;
00490   <a class="code" href="structio__header.html">io_header</a> header;
00491   <a class="code" href="structIDL__STRING.html">IDL_STRING</a> *idl_s;
00492   <span class="keywordtype">char</span> *OutputDir, *Snapbase;
00493   <span class="keywordtype">char</span> buf[1000];
00494   FILE *fd;
00495   <span class="keywordtype">int</span> *Hashtable, *LastHashCell;
00496   <span class="keywordtype">int</span> *Filetable;
00497   <span class="keywordtype">int</span> *NInFiles;
00498   <span class="keywordtype">int</span> hashtabsize, GroupNr, FileNr, GroupLen, Ngroups, TotNgroups, count, Nids;
00499   <span class="keywordtype">int</span> len, offset;
00500   <span class="keywordtype">float</span> *Pos;
00501   <span class="keywordtype">float</span> *Sx, *Sy, *Sz;
00502   <span class="keywordtype">double</span> sx, sy, sz;
00503   <span class="keywordtype">double</span> refx, refy, refz;
00504   <span class="keywordtype">float</span> *pos_read;
00505   <span class="keywordtype">int</span> hash_key;
00506   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> id;
00507   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> *ids, *id_read;
00508 
00509   idl_s = (<a class="code" href="structIDL__STRING.html">IDL_STRING</a> *) argv[0];
00510   OutputDir = idl_s-&gt;<a class="code" href="structIDL__STRING.html#o2">s</a>;
00511   Num = *(<span class="keywordtype">int</span> *) argv[1];
00512   idl_s = (<a class="code" href="structIDL__STRING.html">IDL_STRING</a> *) argv[2];
00513   Snapbase = idl_s-&gt;<a class="code" href="structIDL__STRING.html#o2">s</a>;
00514 
00515   Hashtable = (<span class="keywordtype">int</span> *) argv[3];
00516   Filetable = (<span class="keywordtype">int</span> *) argv[4];
00517   hashtabsize = *(<span class="keywordtype">int</span> *) argv[5];
00518   LastHashCell = (<span class="keywordtype">int</span> *) argv[6];
00519   NInFiles = (<span class="keywordtype">int</span> *) argv[7];
00520   GroupNr = *(<span class="keywordtype">int</span> *) argv[8];
00521   FileNr = *(<span class="keywordtype">int</span> *) argv[9];
00522   GroupLen = *(<span class="keywordtype">int</span> *) argv[10];
00523   Pos = (<span class="keywordtype">float</span> *) argv[11];
00524   Sx = (<span class="keywordtype">float</span> *) argv[12];
00525   Sy = (<span class="keywordtype">float</span> *) argv[13];
00526   Sz = (<span class="keywordtype">float</span> *) argv[14];
00527 
00528   sprintf(buf, <span class="stringliteral">"%s/group_tab_%03d.%d"</span>, OutputDir, Num, FileNr);
00529   <span class="keywordflow">if</span>(!(fd = fopen(buf, <span class="stringliteral">"r"</span>)))
00530     {
00531       printf(<span class="stringliteral">"can't open file `%s'\n"</span>, buf);
00532       <span class="keywordflow">return</span> -1;
00533     }
00534 
00535   fread(&amp;Ngroups, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00536   fread(&amp;Nids, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00537   fread(&amp;TotNgroups, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00538   fread(&amp;NTask, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00539   <span class="comment">/* skip group-len table */</span>
00540   fseek(fd, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>) * Ngroups, SEEK_CUR);
00541   fseek(fd, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>) * GroupNr, SEEK_CUR);
00542   fread(&amp;offset, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00543   fclose(fd);
00544 
00545   ids = malloc(GroupLen * <span class="keyword">sizeof</span>(<span class="keywordtype">long</span> <span class="keywordtype">long</span>));
00546 
00547   sprintf(buf, <span class="stringliteral">"%s/group_ids_%03d.%d"</span>, OutputDir, Num, FileNr);
00548   <span class="keywordflow">if</span>(!(fd = fopen(buf, <span class="stringliteral">"r"</span>)))
00549     {
00550       printf(<span class="stringliteral">"can't open file `%s'\n"</span>, buf);
00551       <span class="keywordflow">return</span> -1;
00552     }
00553   fread(&amp;Ngroups, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00554   fread(&amp;Nids, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00555   fread(&amp;TotNgroups, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00556   fread(&amp;NTask, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00557 
00558   fseek(fd, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span> <span class="keywordtype">long</span>) * offset, SEEK_CUR);
00559   fread(ids, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span> <span class="keywordtype">long</span>), GroupLen, fd);
00560   fclose(fd);
00561 
00562   <span class="keywordflow">for</span>(i = 0; i &lt; hashtabsize; i++)
00563     Filetable[i] &lt;&lt;= 1;
00564 
00565 
00566   <span class="keywordflow">for</span>(i = 0, count = 0; i &lt; GroupLen; i++)
00567     {
00568       hash_key = (ids[i] &gt;&gt; 34);
00569 
00570       <span class="keywordflow">if</span>(hash_key &gt;= hashtabsize)
00571         {
00572           printf(<span class="stringliteral">"bummer\n"</span>);
00573           <span class="keywordflow">return</span> -1;
00574         }
00575 
00576       <span class="keywordflow">if</span>((Filetable[hash_key] &amp; 1) == 0)
00577         {
00578           Filetable[hash_key] |= 1;
00579 
00580           <span class="keywordflow">if</span>(hash_key != LastHashCell[Filetable[hash_key] &gt;&gt; 1])
00581             count += Hashtable[hash_key + 1] - Hashtable[hash_key];
00582           <span class="keywordflow">else</span>
00583             count += NInFiles[Filetable[hash_key] &gt;&gt; 1] - Hashtable[hash_key];
00584         }
00585     }
00586 
00587   pos_read = malloc(3 * count * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));
00588   id_read = malloc(count * <span class="keyword">sizeof</span>(<span class="keywordtype">long</span> <span class="keywordtype">long</span>));
00589 
00590   <span class="keywordflow">for</span>(i = 0, count = 0; i &lt; hashtabsize; i++)
00591     {
00592       <span class="keywordflow">if</span>((Filetable[i] &amp; 1))
00593         {
00594           sprintf(buf, <span class="stringliteral">"%s/%s_%03d.%d"</span>, OutputDir, Snapbase, Num, Filetable[i] &gt;&gt; 1);
00595           <span class="keywordflow">if</span>(!(fd = fopen(buf, <span class="stringliteral">"r"</span>)))
00596             {
00597               printf(<span class="stringliteral">"can't open file `%s'\n"</span>, buf);
00598               <span class="keywordflow">return</span> -1;
00599             }
00600           fread(&amp;dummy, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00601           fread(&amp;header, <span class="keyword">sizeof</span>(<a class="code" href="structio__header.html">io_header</a>), 1, fd);
00602           fread(&amp;dummy, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00603 
00604           BoxSize = header.<a class="code" href="structio__header.html#o9">BoxSize</a>;
00605 
00606           fread(&amp;dummy, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00607           fseek(fd, 3 * Hashtable[i] * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>), SEEK_CUR);
00608 
00609           <span class="keywordflow">if</span>(i != LastHashCell[Filetable[i] &gt;&gt; 1])
00610             len = Hashtable[i + 1] - Hashtable[i];
00611           <span class="keywordflow">else</span>
00612             len = NInFiles[Filetable[i] &gt;&gt; 1] - Hashtable[i];
00613 
00614           fread(&amp;pos_read[3 * count], <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>), 3 * len, fd);
00615 
00616           count += len;
00617           fclose(fd);
00618         }
00619     }
00620 
00621 
00622   <span class="keywordflow">for</span>(i = 0, count = 0; i &lt; hashtabsize; i++)
00623     {
00624       <span class="keywordflow">if</span>((Filetable[i] &amp; 1))
00625         {
00626           sprintf(buf, <span class="stringliteral">"%s/%s_%03d.%d"</span>, OutputDir, Snapbase, Num, Filetable[i] &gt;&gt; 1);
00627           <span class="keywordflow">if</span>(!(fd = fopen(buf, <span class="stringliteral">"r"</span>)))
00628             {
00629               printf(<span class="stringliteral">"can't open file `%s'\n"</span>, buf);
00630               <span class="keywordflow">return</span> -1;
00631             }
00632           fread(&amp;dummy, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00633           fread(&amp;header, <span class="keyword">sizeof</span>(<a class="code" href="structio__header.html">io_header</a>), 1, fd);
00634           fread(&amp;dummy, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00635 
00636           <span class="comment">/* skip positions */</span>
00637           fread(&amp;dummy, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00638           fseek(fd, dummy, SEEK_CUR);
00639           fread(&amp;dummy, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00640 
00641           <span class="comment">/* skip velocities */</span>
00642           fread(&amp;dummy, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00643           fseek(fd, dummy, SEEK_CUR);
00644           fread(&amp;dummy, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00645 
00646           fread(&amp;dummy, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00647           fseek(fd, Hashtable[i] * <span class="keyword">sizeof</span>(<span class="keywordtype">long</span> <span class="keywordtype">long</span>), SEEK_CUR);
00648 
00649           <span class="keywordflow">if</span>(i != LastHashCell[Filetable[i] &gt;&gt; 1])
00650             len = Hashtable[i + 1] - Hashtable[i];
00651           <span class="keywordflow">else</span>
00652             len = NInFiles[Filetable[i] &gt;&gt; 1] - Hashtable[i];
00653 
00654           fread(&amp;id_read[count], <span class="keyword">sizeof</span>(<span class="keywordtype">long</span> <span class="keywordtype">long</span>), len, fd);
00655 
00656           count += len;
00657           fclose(fd);
00658         }
00659     }
00660 
00661   <span class="keywordflow">for</span>(i = 0; i &lt; GroupLen; i++)
00662     ids[i] &amp;= ((((<span class="keywordtype">long</span> long) 1) &lt;&lt; 34) - 1);
00663 
00664   <span class="keywordflow">for</span>(i = 0; i &lt; count; i++)
00665     id_read[i] = ((id_read[i] &amp; ((((<span class="keywordtype">long</span> long) 1) &lt;&lt; 34) - 1)) &lt;&lt; 29) + i;
00666 
00667   qsort(ids, GroupLen, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span> <span class="keywordtype">long</span>), <a class="code" href="groupstuff_8c.html#a22">id_sort_compare_key</a>);
00668   qsort(id_read, count, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span> <span class="keywordtype">long</span>), <a class="code" href="groupstuff_8c.html#a22">id_sort_compare_key</a>);
00669 
00670   <span class="keywordflow">if</span>(count &lt; GroupLen)
00671     {
00672       printf(<span class="stringliteral">"PROBLEM! count=%d GroupLen=%d\n"</span>, count, GroupLen);
00673       printf(<span class="stringliteral">"Something seems to be wrong here=!\n"</span>);
00674     }
00675 
00676   <span class="keywordflow">for</span>(i = 0, n = 0; i &lt; GroupLen &amp;&amp; n &lt; count; i++)
00677     {
00678       <span class="keywordtype">id</span> = (id_read[n] &gt;&gt; 29);
00679 
00680       <span class="keywordflow">while</span>(n &lt; count &amp;&amp; <span class="keywordtype">id</span> &lt; ids[i])
00681         {
00682           n++;
00683           <span class="keywordtype">id</span> = (id_read[n] &gt;&gt; 29);
00684         }
00685 
00686       <span class="keywordflow">if</span>(<span class="keywordtype">id</span> != ids[i])
00687         {
00688           printf(<span class="stringliteral">"We have a mismatch! (i=%d) something is wrong here.\n"</span>, i);
00689         }
00690 
00691       ind = (id_read[n] &amp; ((1 &lt;&lt; 29) - 1));
00692 
00693       <span class="keywordflow">for</span>(j = 0; j &lt; 3; j++)
00694         Pos[i * 3 + j] = pos_read[ind * 3 + j];
00695     }
00696 
00697   sx = sy = sz = 0;
00698   refx = Pos[0];
00699   refy = Pos[1];
00700   refz = Pos[2];
00701 
00702   <span class="keywordflow">for</span>(i = 0; i &lt; GroupLen; i++)
00703     {
00704       Pos[i * 3 + 0] = <a class="code" href="groupstuff_8h.html#a13">fof_periodic</a>(Pos[i * 3 + 0] - refx);
00705       Pos[i * 3 + 1] = <a class="code" href="groupstuff_8h.html#a13">fof_periodic</a>(Pos[i * 3 + 1] - refy);
00706       Pos[i * 3 + 2] = <a class="code" href="groupstuff_8h.html#a13">fof_periodic</a>(Pos[i * 3 + 2] - refz);
00707     }
00708 
00709   <span class="keywordflow">for</span>(i = 0; i &lt; GroupLen; i++)
00710     {
00711       sx += Pos[i * 3 + 0];
00712       sy += Pos[i * 3 + 1];
00713       sz += Pos[i * 3 + 2];
00714     }
00715 
00716   sx /= GroupLen;
00717   sy /= GroupLen;
00718   sz /= GroupLen;
00719 
00720   <span class="keywordflow">for</span>(i = 0; i &lt; GroupLen; i++)
00721     {
00722       Pos[i * 3 + 0] -= sx;
00723       Pos[i * 3 + 1] -= sy;
00724       Pos[i * 3 + 2] -= sz;
00725     }
00726 
00727   <span class="keywordflow">for</span>(i = 0; i &lt; hashtabsize; i++)
00728     Filetable[i] &gt;&gt;= 1;
00729 
00730   free(id_read);
00731   free(pos_read);
00732   free(ids);
00733 
00734 
00735   *Sx = <a class="code" href="groupstuff_8h.html#a12">fof_periodic_wrap</a>(sx + refx);
00736   *Sy = <a class="code" href="groupstuff_8h.html#a12">fof_periodic_wrap</a>(sy + refy);
00737   *Sz = <a class="code" href="groupstuff_8h.html#a12">fof_periodic_wrap</a>(sz + refz);
00738 
00739   <span class="keywordflow">return</span> 0;
00740 }
00741 
00742 
<a name="l00743"></a><a class="code" href="groupstuff_8h.html#a12">00743</a> <span class="keywordtype">double</span> <a class="code" href="groupstuff_8h.html#a12">fof_periodic_wrap</a>(<span class="keywordtype">double</span> x)
00744 {
00745   <span class="keywordflow">while</span>(x &gt;= BoxSize)
00746     x -= BoxSize;
00747 
00748   <span class="keywordflow">while</span>(x &lt; 0)
00749     x += BoxSize;
00750 
00751   <span class="keywordflow">return</span> x;
00752 }
00753 
00754 
<a name="l00755"></a><a class="code" href="groupstuff_8h.html#a13">00755</a> <span class="keywordtype">double</span> <a class="code" href="groupstuff_8h.html#a13">fof_periodic</a>(<span class="keywordtype">double</span> x)
00756 {
00757   <span class="keywordflow">if</span>(x &gt;= 0.5 * BoxSize)
00758     x -= BoxSize;
00759 
00760   <span class="keywordflow">if</span>(x &lt; -0.5 * BoxSize)
00761     x += BoxSize;
00762 
00763   <span class="keywordflow">return</span> x;
00764 }
00765 
00766 
<a name="l00767"></a><a class="code" href="groupstuff_8h.html#a10">00767</a> <span class="keywordtype">int</span> <a class="code" href="groupstuff_8h.html#a10">id_sort_compare_key</a>(<span class="keyword">const</span> <span class="keywordtype">void</span> *a, <span class="keyword">const</span> <span class="keywordtype">void</span> *b)
00768 {
00769   <span class="keywordflow">if</span>(*((<span class="keywordtype">long</span> <span class="keywordtype">long</span> *) a) &lt; *((<span class="keywordtype">long</span> <span class="keywordtype">long</span> *) b))
00770     <span class="keywordflow">return</span> -1;
00771 
00772   <span class="keywordflow">if</span>(*((<span class="keywordtype">long</span> <span class="keywordtype">long</span> *) a) &gt; *((<span class="keywordtype">long</span> <span class="keywordtype">long</span> *) b))
00773     <span class="keywordflow">return</span> +1;
00774 
00775   <span class="keywordflow">return</span> 0;
00776 }
00777 
00778 
00779 
<a name="l00780"></a><a class="code" href="groupstuff_8h.html#a1">00780</a> <span class="keywordtype">int</span> <a class="code" href="groupstuff_8h.html#a1">get_spherical_region_count</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">void</span> *argv[])
00781 {
00782   <span class="keywordtype">int</span> Num, dummy;
00783   <a class="code" href="structio__header.html">io_header</a> header;
00784   <a class="code" href="structIDL__STRING.html">IDL_STRING</a> *idl_s;
00785   <span class="keywordtype">char</span> *OutputDir, *Snapbase;
00786   <span class="keywordtype">char</span> buf[1000];
00787   FILE *fd;
00788   <span class="keywordtype">int</span> *Hashtable, *LastHashCell;
00789   <span class="keywordtype">int</span> *Filetable;
00790   <span class="keywordtype">int</span> *NInFiles;
00791   <span class="keywordtype">int</span> hashtabsize, count;
00792   <span class="keywordtype">float</span> Sx, Sy, Sz, Rad;
00793   <span class="keywordtype">int</span> hash_key;
00794   <span class="keywordtype">double</span> cellsize;
00795   <span class="keywordtype">int</span> cells, cx, cy, cz, ix, iy, iz, iix, iiy, iiz, base, hashbits;
00796 
00797   idl_s = (<a class="code" href="structIDL__STRING.html">IDL_STRING</a> *) argv[0];
00798   OutputDir = idl_s-&gt;<a class="code" href="structIDL__STRING.html#o2">s</a>;
00799   Num = *(<span class="keywordtype">int</span> *) argv[1];
00800   idl_s = (<a class="code" href="structIDL__STRING.html">IDL_STRING</a> *) argv[2];
00801   Snapbase = idl_s-&gt;<a class="code" href="structIDL__STRING.html#o2">s</a>;
00802 
00803   Hashtable = (<span class="keywordtype">int</span> *) argv[3];
00804   Filetable = (<span class="keywordtype">int</span> *) argv[4];
00805   hashtabsize = *(<span class="keywordtype">int</span> *) argv[5];
00806   LastHashCell = (<span class="keywordtype">int</span> *) argv[6];
00807   NInFiles = (<span class="keywordtype">int</span> *) argv[7];
00808   Sx = *(<span class="keywordtype">float</span> *) argv[8];
00809   Sy = *(<span class="keywordtype">float</span> *) argv[9];
00810   Sz = *(<span class="keywordtype">float</span> *) argv[10];
00811   Rad = *(<span class="keywordtype">float</span> *) argv[11];
00812 
00813 
00814   sprintf(buf, <span class="stringliteral">"%s/%s_%03d.%d"</span>, OutputDir, Snapbase, Num, 0);
00815   <span class="keywordflow">if</span>(!(fd = fopen(buf, <span class="stringliteral">"r"</span>)))
00816     {
00817       printf(<span class="stringliteral">"can't open file `%s'\n"</span>, buf);
00818       <span class="keywordflow">return</span> -1;
00819     }
00820   fread(&amp;dummy, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00821   fread(&amp;header, <span class="keyword">sizeof</span>(<a class="code" href="structio__header.html">io_header</a>), 1, fd);
00822   fread(&amp;dummy, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00823   fclose(fd);
00824 
00825   BoxSize = header.<a class="code" href="structio__header.html#o9">BoxSize</a>;
00826 
00827  
00828   base = 1;
00829   <span class="keywordflow">while</span>(base * base * base &lt; hashtabsize)
00830     base *= 2;
00831 
00832   hashbits = 1;
00833   <span class="keywordflow">while</span>((1 &lt;&lt; hashbits) &lt; base)
00834     hashbits++;
00835 
00836   cellsize = BoxSize / base;
00837 
00838   cells = Rad/cellsize + 1; 
00839   cx = Sx/cellsize;
00840   cy = Sy/cellsize;
00841   cz = Sz/cellsize;
00842 
00843 
00844   count = 0;
00845 
00846   <span class="keywordflow">for</span>(ix = cx - cells; ix &lt;= cx + cells; ix++)
00847     <span class="keywordflow">for</span>(iy = cy - cells; iy &lt;= cy + cells; iy++)
00848       <span class="keywordflow">for</span>(iz = cz - cells; iz &lt;= cz + cells; iz++)
00849         {
00850           iix = ix;
00851           iiy = iy;
00852           iiz = iz;
00853 
00854           <span class="keywordflow">if</span>(iix&lt;0)
00855             iix += base;
00856           <span class="keywordflow">if</span>(iix&gt;=base)
00857             iix -= base;
00858 
00859           <span class="keywordflow">if</span>(iiy&lt;0)
00860             iiy += base;
00861           <span class="keywordflow">if</span>(iiy&gt;=base)
00862             iiy -= base;
00863 
00864           <span class="keywordflow">if</span>(iiz&lt;0)
00865             iiz += base;
00866           <span class="keywordflow">if</span>(iiz&gt;=base)
00867             iiz -= base;
00868 
00869           hash_key = <a class="code" href="groupstuff_8h.html#a14">peano_hilbert_key</a>(iix, iiy, iiz, hashbits);
00870 
00871           <span class="keywordflow">if</span>(hash_key != LastHashCell[Filetable[hash_key]])
00872             count += Hashtable[hash_key + 1] - Hashtable[hash_key];
00873           <span class="keywordflow">else</span>
00874             count += NInFiles[Filetable[hash_key]] - Hashtable[hash_key];
00875         }
00876 
00877   <span class="keywordflow">return</span> count;
00878 }
00879 
00880 
00881 
<a name="l00882"></a><a class="code" href="groupstuff_8h.html#a2">00882</a> <span class="keywordtype">int</span> <a class="code" href="groupstuff_8h.html#a2">get_spherical_region_coordinates</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">void</span> *argv[])
00883 {
00884   <span class="keywordtype">int</span> Num, dummy;
00885   <span class="keywordtype">int</span> i;
00886   <a class="code" href="structio__header.html">io_header</a> header;
00887   <a class="code" href="structIDL__STRING.html">IDL_STRING</a> *idl_s;
00888   <span class="keywordtype">char</span> *OutputDir, *Snapbase;
00889   <span class="keywordtype">char</span> buf[1000];
00890   FILE *fd;
00891   <span class="keywordtype">int</span> *Hashtable, *LastHashCell;
00892   <span class="keywordtype">int</span> *Filetable;
00893   <span class="keywordtype">int</span> *NInFiles;
00894   <span class="keywordtype">int</span> hashtabsize, count;
00895   <span class="keywordtype">int</span> len;
00896   <span class="keywordtype">float</span> *Pos;
00897   <span class="keywordtype">float</span> Sx, Sy, Sz, Rad;
00898   <span class="keywordtype">double</span> cellsize;
00899   <span class="keywordtype">int</span> cells, cx, cy, cz, ix, iy, iz, iix, iiy, iiz, base, hashbits, hashkey;
00900   
00901 
00902   idl_s = (<a class="code" href="structIDL__STRING.html">IDL_STRING</a> *) argv[0];
00903   OutputDir = idl_s-&gt;<a class="code" href="structIDL__STRING.html#o2">s</a>;
00904   Num = *(<span class="keywordtype">int</span> *) argv[1];
00905   idl_s = (<a class="code" href="structIDL__STRING.html">IDL_STRING</a> *) argv[2];
00906   Snapbase = idl_s-&gt;<a class="code" href="structIDL__STRING.html#o2">s</a>;
00907 
00908   Hashtable = (<span class="keywordtype">int</span> *) argv[3];
00909   Filetable = (<span class="keywordtype">int</span> *) argv[4];
00910   hashtabsize = *(<span class="keywordtype">int</span> *) argv[5];
00911   LastHashCell = (<span class="keywordtype">int</span> *) argv[6];
00912   NInFiles = (<span class="keywordtype">int</span> *) argv[7];
00913   Sx = *(<span class="keywordtype">float</span> *) argv[8];
00914   Sy = *(<span class="keywordtype">float</span> *) argv[9];
00915   Sz = *(<span class="keywordtype">float</span> *) argv[10];
00916   Rad = *(<span class="keywordtype">float</span> *) argv[11];
00917   Pos = (<span class="keywordtype">float</span> *) argv[12];
00918 
00919 
00920 
00921   sprintf(buf, <span class="stringliteral">"%s/%s_%03d.%d"</span>, OutputDir, Snapbase, Num, 0);
00922   <span class="keywordflow">if</span>(!(fd = fopen(buf, <span class="stringliteral">"r"</span>)))
00923     {
00924       printf(<span class="stringliteral">"can't open file `%s'\n"</span>, buf);
00925       <span class="keywordflow">return</span> -1;
00926     }
00927   fread(&amp;dummy, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00928   fread(&amp;header, <span class="keyword">sizeof</span>(<a class="code" href="structio__header.html">io_header</a>), 1, fd);
00929   fread(&amp;dummy, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00930   fclose(fd);
00931 
00932   BoxSize = header.<a class="code" href="structio__header.html#o9">BoxSize</a>;
00933 
00934 
00935 
00936   base = 1;
00937   <span class="keywordflow">while</span>(base * base * base &lt; hashtabsize)
00938     base *= 2;
00939 
00940   hashbits = 1;
00941   <span class="keywordflow">while</span>((1 &lt;&lt; hashbits) &lt; base)
00942     hashbits++;
00943 
00944   cellsize = BoxSize / base;
00945 
00946   cells = Rad/cellsize + 1; 
00947   cx = Sx/cellsize;
00948   cy = Sy/cellsize;
00949   cz = Sz/cellsize;
00950   
00951 
00952   count = 0;
00953 
00954   <span class="keywordflow">for</span>(ix = cx - cells; ix &lt;= cx + cells; ix++)
00955     <span class="keywordflow">for</span>(iy = cy - cells; iy &lt;= cy + cells; iy++)
00956       <span class="keywordflow">for</span>(iz = cz - cells; iz &lt;= cz + cells; iz++)
00957         {
00958           iix = ix;
00959           iiy = iy;
00960           iiz = iz;
00961 
00962           <span class="keywordflow">if</span>(iix&lt;0)
00963             iix += base;
00964           <span class="keywordflow">if</span>(iix&gt;=base)
00965             iix -= base;
00966 
00967           <span class="keywordflow">if</span>(iiy&lt;0)
00968             iiy += base;
00969           <span class="keywordflow">if</span>(iiy&gt;=base)
00970             iiy -= base;
00971 
00972           <span class="keywordflow">if</span>(iiz&lt;0)
00973             iiz += base;
00974           <span class="keywordflow">if</span>(iiz&gt;=base)
00975             iiz -= base;
00976 
00977           hashkey = <a class="code" href="groupstuff_8h.html#a14">peano_hilbert_key</a>(iix, iiy, iiz, hashbits);
00978 
00979           sprintf(buf, <span class="stringliteral">"%s/%s_%03d.%d"</span>, OutputDir, Snapbase, Num, Filetable[hashkey]);
00980           <span class="keywordflow">if</span>(!(fd = fopen(buf, <span class="stringliteral">"r"</span>)))
00981             {
00982               printf(<span class="stringliteral">"can't open file `%s'\n"</span>, buf);
00983               <span class="keywordflow">return</span> -1;
00984             }
00985           fread(&amp;dummy, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00986           fread(&amp;header, <span class="keyword">sizeof</span>(io_header), 1, fd);
00987           fread(&amp;dummy, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00988 
00989           BoxSize = header.<a class="code" href="structio__header.html#o9">BoxSize</a>;
00990 
00991           fread(&amp;dummy, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 1, fd);
00992           fseek(fd, 3 * Hashtable[hashkey] * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>), SEEK_CUR);
00993 
00994           <span class="keywordflow">if</span>(hashkey != LastHashCell[Filetable[hashkey]])
00995             len = Hashtable[hashkey + 1] - Hashtable[hashkey];
00996           <span class="keywordflow">else</span>
00997             len = NInFiles[Filetable[hashkey]] - Hashtable[hashkey];
00998 
00999           fread(&amp;Pos[3 * count], <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>), 3 * len, fd);
01000 
01001           count += len;
01002           fclose(fd);
01003         }
01004 
01005 
01006 
01007   <span class="keywordflow">for</span>(i = 0; i &lt; count; i++)
01008     {
01009       Pos[i * 3 + 0] = <a class="code" href="groupstuff_8h.html#a13">fof_periodic</a>(Pos[i * 3 + 0] - Sx);
01010       Pos[i * 3 + 1] = <a class="code" href="groupstuff_8h.html#a13">fof_periodic</a>(Pos[i * 3 + 1] - Sy);
01011       Pos[i * 3 + 2] = <a class="code" href="groupstuff_8h.html#a13">fof_periodic</a>(Pos[i * 3 + 2] - Sz);
01012     }
01013 
01014   <span class="keywordflow">return</span> 0;
01015 }
01016 
01017 
01018 
01019 
01020 
01021 
01022 
01023 
01024 
01025 
01026 
01027 
01028 
01029 
01030 
01031 
01032 
01033 
01034 
01035 
01036 
01037 
01038 
01039 <span class="keyword">static</span> <span class="keywordtype">int</span> quadrants[24][2][2][2] = {
01040   <span class="comment">/* rotx=0, roty=0-3 */</span>
01041   {{{0, 7}, {1, 6}}, {{3, 4}, {2, 5}}},
01042   {{{7, 4}, {6, 5}}, {{0, 3}, {1, 2}}},
01043   {{{4, 3}, {5, 2}}, {{7, 0}, {6, 1}}},
01044   {{{3, 0}, {2, 1}}, {{4, 7}, {5, 6}}},
01045   <span class="comment">/* rotx=1, roty=0-3 */</span>
01046   {{{1, 0}, {6, 7}}, {{2, 3}, {5, 4}}},
01047   {{{0, 3}, {7, 4}}, {{1, 2}, {6, 5}}},
01048   {{{3, 2}, {4, 5}}, {{0, 1}, {7, 6}}},
01049   {{{2, 1}, {5, 6}}, {{3, 0}, {4, 7}}},
01050   <span class="comment">/* rotx=2, roty=0-3 */</span>
01051   {{{6, 1}, {7, 0}}, {{5, 2}, {4, 3}}},
01052   {{{1, 2}, {0, 3}}, {{6, 5}, {7, 4}}},
01053   {{{2, 5}, {3, 4}}, {{1, 6}, {0, 7}}},
01054   {{{5, 6}, {4, 7}}, {{2, 1}, {3, 0}}},
01055   <span class="comment">/* rotx=3, roty=0-3 */</span>
01056   {{{7, 6}, {0, 1}}, {{4, 5}, {3, 2}}},
01057   {{{6, 5}, {1, 2}}, {{7, 4}, {0, 3}}},
01058   {{{5, 4}, {2, 3}}, {{6, 7}, {1, 0}}},
01059   {{{4, 7}, {3, 0}}, {{5, 6}, {2, 1}}},
01060   <span class="comment">/* rotx=4, roty=0-3 */</span>
01061   {{{6, 7}, {5, 4}}, {{1, 0}, {2, 3}}},
01062   {{{7, 0}, {4, 3}}, {{6, 1}, {5, 2}}},
01063   {{{0, 1}, {3, 2}}, {{7, 6}, {4, 5}}},
01064   {{{1, 6}, {2, 5}}, {{0, 7}, {3, 4}}},
01065   <span class="comment">/* rotx=5, roty=0-3 */</span>
01066   {{{2, 3}, {1, 0}}, {{5, 4}, {6, 7}}},
01067   {{{3, 4}, {0, 7}}, {{2, 5}, {1, 6}}},
01068   {{{4, 5}, {7, 6}}, {{3, 2}, {0, 1}}},
01069   {{{5, 2}, {6, 1}}, {{4, 3}, {7, 0}}}
01070 };
01071 
01072 
01073 <span class="keyword">static</span> <span class="keywordtype">int</span> rotxmap_table[24] = { 4, 5, 6, 7, 8, 9, 10, 11,
01074   12, 13, 14, 15, 0, 1, 2, 3, 17, 18, 19, 16, 23, 20, 21, 22
01075 };
01076 
01077 <span class="keyword">static</span> <span class="keywordtype">int</span> rotymap_table[24] = { 1, 2, 3, 0, 16, 17, 18, 19,
01078   11, 8, 9, 10, 22, 23, 20, 21, 14, 15, 12, 13, 4, 5, 6, 7
01079 };
01080 
01081 <span class="keyword">static</span> <span class="keywordtype">int</span> rotx_table[8] = { 3, 0, 0, 2, 2, 0, 0, 1 };
01082 <span class="keyword">static</span> <span class="keywordtype">int</span> roty_table[8] = { 0, 1, 1, 2, 2, 3, 3, 0 };
01083 
01084 <span class="keyword">static</span> <span class="keywordtype">int</span> sense_table[8] = { -1, -1, -1, +1, +1, -1, -1, -1 };
01085 
01086 <span class="keyword">static</span> <span class="keywordtype">int</span> flag_quadrants_inverse = 1;
01087 <span class="keyword">static</span> <span class="keywordtype">char</span> quadrants_inverse_x[24][8];
01088 <span class="keyword">static</span> <span class="keywordtype">char</span> quadrants_inverse_y[24][8];
01089 <span class="keyword">static</span> <span class="keywordtype">char</span> quadrants_inverse_z[24][8];
01090 
01091 
<a name="l01095"></a><a class="code" href="groupstuff_8h.html#a14">01095</a> <a class="code" href="groupstuff_8h.html#a0">peanokey</a> <a class="code" href="groupstuff_8h.html#a14">peano_hilbert_key</a>(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> z, <span class="keywordtype">int</span> bits)
01096 {
01097   <span class="keywordtype">int</span> i, quad, bitx, bity, bitz;
01098   <span class="keywordtype">int</span> mask, rotation, rotx, roty, sense;
01099   <a class="code" href="groupstuff_8h.html#a0">peanokey</a> key;
01100 
01101 
01102   mask = 1 &lt;&lt; (bits - 1);
01103   key = 0;
01104   rotation = 0;
01105   sense = 1;
01106 
01107 
01108   <span class="keywordflow">for</span>(i = 0; i &lt; bits; i++, mask &gt;&gt;= 1)
01109     {
01110       bitx = (x &amp; mask) ? 1 : 0;
01111       bity = (y &amp; mask) ? 1 : 0;
01112       bitz = (z &amp; mask) ? 1 : 0;
01113 
01114       quad = quadrants[rotation][bitx][bity][bitz];
01115 
01116       key &lt;&lt;= 3;
01117       key += (sense == 1) ? (quad) : (7 - quad);
01118 
01119       rotx = rotx_table[quad];
01120       roty = roty_table[quad];
01121       sense *= sense_table[quad];
01122 
01123       <span class="keywordflow">while</span>(rotx &gt; 0)
01124         {
01125           rotation = rotxmap_table[rotation];
01126           rotx--;
01127         }
01128 
01129       <span class="keywordflow">while</span>(roty &gt; 0)
01130         {
01131           rotation = rotymap_table[rotation];
01132           roty--;
01133         }
01134     }
01135 
01136   <span class="keywordflow">return</span> key;
01137 }
01138 
01139 
<a name="l01145"></a><a class="code" href="groupstuff_8h.html#a15">01145</a> <span class="keywordtype">void</span> <a class="code" href="groupstuff_8h.html#a15">peano_hilbert_key_inverse</a>(peanokey key, <span class="keywordtype">int</span> bits, <span class="keywordtype">int</span> *x, <span class="keywordtype">int</span> *y, <span class="keywordtype">int</span> *z)
01146 {
01147   <span class="keywordtype">int</span> i, keypart, bitx, bity, bitz, mask, quad, rotation, shift;
01148   <span class="keywordtype">char</span> sense, rotx, roty;
01149 
01150   <span class="keywordflow">if</span>(flag_quadrants_inverse)
01151     {
01152       flag_quadrants_inverse = 0;
01153       <span class="keywordflow">for</span>(rotation = 0; rotation &lt; 24; rotation++)
01154         <span class="keywordflow">for</span>(bitx = 0; bitx &lt; 2; bitx++)
01155           <span class="keywordflow">for</span>(bity = 0; bity &lt; 2; bity++)
01156             <span class="keywordflow">for</span>(bitz = 0; bitz &lt; 2; bitz++)
01157               {
01158                 quad = quadrants[rotation][bitx][bity][bitz];
01159                 quadrants_inverse_x[rotation][quad] = bitx;
01160                 quadrants_inverse_y[rotation][quad] = bity;
01161                 quadrants_inverse_z[rotation][quad] = bitz;
01162               }
01163     }
01164 
01165   shift = 3 * (bits - 1);
01166   mask = 7 &lt;&lt; shift;
01167 
01168   rotation = 0;
01169   sense = 1;
01170 
01171   *x = *y = *z = 0;
01172 
01173   <span class="keywordflow">for</span>(i = 0; i &lt; bits; i++, mask &gt;&gt;= 3, shift -= 3)
01174     {
01175       keypart = (key &amp; mask) &gt;&gt; shift;
01176 
01177       quad = (sense == 1) ? (keypart) : (7 - keypart);
01178 
01179       *x = (*x &lt;&lt; 1) + quadrants_inverse_x[rotation][quad];
01180       *y = (*y &lt;&lt; 1) + quadrants_inverse_y[rotation][quad];
01181       *z = (*z &lt;&lt; 1) + quadrants_inverse_z[rotation][quad];
01182 
01183       rotx = rotx_table[quad];
01184       roty = roty_table[quad];
01185       sense *= sense_table[quad];
01186 
01187       <span class="keywordflow">while</span>(rotx &gt; 0)
01188         {
01189           rotation = rotxmap_table[rotation];
01190           rotx--;
01191         }
01192 
01193       <span class="keywordflow">while</span>(roty &gt; 0)
01194         {
01195           rotation = rotymap_table[rotation];
01196           roty--;
01197         }
01198     }
01199 }
01200 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Nov 15 15:13:48 2004 for IDL-Grouplib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
