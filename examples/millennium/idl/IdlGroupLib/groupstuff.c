#include <stdio.h>
#include <stdlib.h>

#include "groupstuff.h"

/*! \mainpage Reference documentation for IDL-Grouplib

\author Volker Springel \n
        Max-Planck-Institute for Astrophysics \n
        Garching, Germany \n
        volker@mpa-garching.mpg.de \n
\n

This C-library is meant to be called by IDL (or other languages) and
provides an easy-to-use interface for the groupcatalogues generated by
the FOF algorithm of <b>L-GADGET2</b>.
*/

typedef struct
{
  unsigned int slen;
  unsigned int stype;
  char *s;
}
IDL_STRING;


typedef struct
{
  int npart[6];
  double mass[6];
  double time;
  double redshift;
  int flag_sfr;
  int flag_feedback;
  int npartTotal[6];
  int flag_cooling;
  int num_files;
  double BoxSize;
  double Omega0;
  double OmegaLambda;
  double HubbleParam;
  int flag_stellarage;
  int flag_metals;
  int hashtabsize;
  char fill[84];		/* fills to 256 Bytes */
}
io_header;



typedef struct
{
  int len;
  int file;
  int offset;
}
cat_data;





static double BoxSize;

/*  Expected input values:
 *  char*    Output directory
 *  int      snapshot number
 */
int get_total_number_of_groups(int argc, void *argv[])
{
  int Ngroups, Nids, TotNgroups, NTask, Num;
  IDL_STRING *idl_s;
  char *OutputDir;
  char buf[1000];
  FILE *fd;

  idl_s = (IDL_STRING *) argv[0];
  OutputDir = idl_s->s;
  Num = *(int *) argv[1];

  sprintf(buf, "%s/group_tab_%03d.0", OutputDir, Num);
  if(!(fd = fopen(buf, "r")))
    {
      printf("can't open file `%s'\n", buf);
      return -1;
    }

  fread(&Ngroups, sizeof(int), 1, fd);
  fread(&Nids, sizeof(int), 1, fd);
  fread(&TotNgroups, sizeof(int), 1, fd);
  fread(&NTask, sizeof(int), 1, fd);
  fclose(fd);

  return TotNgroups;
}


int get_minimum_group_len(int argc, void *argv[])
{
  int Ngroups, Nids, TotNgroups, NTask, Num, GroupMinLen;
  IDL_STRING *idl_s;
  char *OutputDir;
  char buf[1000];
  FILE *fd;

  idl_s = (IDL_STRING *) argv[0];
  OutputDir = idl_s->s;
  Num = *(int *) argv[1];

  sprintf(buf, "%s/group_tab_%03d.0", OutputDir, Num);
  if(!(fd = fopen(buf, "r")))
    {
      printf("can't open file `%s'\n", buf);
      return -1;
    }

  fread(&Ngroups, sizeof(int), 1, fd);
  fread(&Nids, sizeof(int), 1, fd);
  fread(&TotNgroups, sizeof(int), 1, fd);
  fread(&NTask, sizeof(int), 1, fd);
  fseek(fd, sizeof(int) * Ngroups, SEEK_CUR);	/* skip GroupLen */
  fseek(fd, sizeof(int) * Ngroups, SEEK_CUR);	/* skip GroupOffset */
  fread(&GroupMinLen, sizeof(int), 1, fd);
  fclose(fd);

  return GroupMinLen;
}



int get_groupcount_below_minimum_len(int argc, void *argv[])
{
  int Ngroups, Nids, TotNgroups, NTask, Num, i, filenr, GroupMinLen;
  int *count;
  double *CountBelowMinLen;
  double *countIDs;
  long long totIds;
  IDL_STRING *idl_s;
  char *OutputDir;
  char buf[1000];
  FILE *fd;

  idl_s = (IDL_STRING *) argv[0];
  OutputDir = idl_s->s;
  Num = *(int *) argv[1];

  CountBelowMinLen = (double *) argv[2];

  countIDs = (double *) argv[3];

  sprintf(buf, "%s/group_tab_%03d.0", OutputDir, Num);
  if(!(fd = fopen(buf, "r")))
    {
      printf("can't open file `%s'\n", buf);
      return -1;
    }

  fread(&Ngroups, sizeof(int), 1, fd);
  fread(&Nids, sizeof(int), 1, fd);
  fread(&TotNgroups, sizeof(int), 1, fd);
  fread(&NTask, sizeof(int), 1, fd);
  fseek(fd, sizeof(int) * Ngroups, SEEK_CUR);	/* skip GroupLen */
  fseek(fd, sizeof(int) * Ngroups, SEEK_CUR);	/* skip GroupOffset */
  fread(&GroupMinLen, sizeof(int), 1, fd);
  fclose(fd);


  count = malloc(GroupMinLen * sizeof(int));

  for(i = 0; i < GroupMinLen; i++)
    CountBelowMinLen[i] = 0;

  totIds = 0;

  for(filenr = 0; filenr < NTask; filenr++)
    {
      sprintf(buf, "%s/group_tab_%03d.%d", OutputDir, Num, filenr);
      if(!(fd = fopen(buf, "r")))
	{
	  printf("can't open file `%s'\n", buf);
	  return -1;
	}

      fread(&Ngroups, sizeof(int), 1, fd);
      fread(&Nids, sizeof(int), 1, fd);
      fread(&TotNgroups, sizeof(int), 1, fd);
      fread(&NTask, sizeof(int), 1, fd);
      fseek(fd, sizeof(int) * Ngroups, SEEK_CUR);	/* skip GroupLen */
      fseek(fd, sizeof(int) * Ngroups, SEEK_CUR);	/* skip GroupOffset */
      fread(&GroupMinLen, sizeof(int), 1, fd);
      fread(count, sizeof(int), GroupMinLen, fd);

      totIds += Nids;

      for(i = 0; i < GroupMinLen; i++)
	CountBelowMinLen[i] += count[i];

      fclose(fd);
    }

  free(count);

  *countIDs = (double)(totIds);

  return GroupMinLen;
}







int get_group_catalogue(int argc, void *argv[])
{
  int Ngroups, Nids, TotNgroups, NTask, Num, count, i, filenr;
  int *GroupLen, *GroupFileNr, *GroupNr;
  IDL_STRING *idl_s;
  cat_data *temp;
  char *OutputDir;
  char buf[1000];
  FILE *fd;

  idl_s = (IDL_STRING *) argv[0];
  OutputDir = idl_s->s;
  Num = *(int *) argv[1];

  GroupLen = (int *) argv[2];
  GroupFileNr = (int *) argv[3];
  GroupNr = (int *) argv[4];

  sprintf(buf, "%s/group_tab_%03d.0", OutputDir, Num);
  if(!(fd = fopen(buf, "r")))
    {
      printf("can't open file `%s'\n", buf);
      return -1;
    }

  fread(&Ngroups, sizeof(int), 1, fd);
  fread(&Nids, sizeof(int), 1, fd);
  fread(&TotNgroups, sizeof(int), 1, fd);
  fread(&NTask, sizeof(int), 1, fd);
  fclose(fd);


  for(filenr = 0, count = 0; filenr < NTask; filenr++)
    {
      sprintf(buf, "%s/group_tab_%03d.%d", OutputDir, Num, filenr);
      if(!(fd = fopen(buf, "r")))
	{
	  printf("can't open file `%s'\n", buf);
	  return -1;
	}

      fread(&Ngroups, sizeof(int), 1, fd);
      fread(&Nids, sizeof(int), 1, fd);
      fread(&TotNgroups, sizeof(int), 1, fd);
      fread(&NTask, sizeof(int), 1, fd);

      fread(&GroupLen[count], sizeof(int), Ngroups, fd);

      for(i = 0; i < Ngroups; i++)
	{
	  GroupFileNr[i + count] = filenr;
	  GroupNr[i + count] = i;
	}

      count += Ngroups;

      fclose(fd);
    }

  temp = malloc(sizeof(cat_data) * TotNgroups);

  for(i = 0; i < TotNgroups; i++)
    {
      temp[i].len = GroupLen[i];
      temp[i].file = GroupFileNr[i];
      temp[i].offset = GroupNr[i];
    }

  qsort(temp, TotNgroups, sizeof(cat_data), id_sort_groups);

  for(i = 0; i < TotNgroups; i++)
    {
      GroupLen[i] = temp[i].len;
      GroupFileNr[i] = temp[i].file;
      GroupNr[i] = temp[i].offset;
    }

  free(temp);

  return TotNgroups;
}

int id_sort_groups(const void *a, const void *b)
{
  if(((cat_data *) a)->len > ((cat_data *) b)->len)
    return -1;

  if(((cat_data *) a)->len < ((cat_data *) b)->len)
    return +1;

  return 0;
}


int get_hash_table_size(int argc, void *argv[])
{
  int Num, dummy;
  int *NFiles;
  io_header header;
  IDL_STRING *idl_s;
  char *OutputDir, *Snapbase;
  char buf[1000];
  FILE *fd;

  idl_s = (IDL_STRING *) argv[0];
  OutputDir = idl_s->s;
  Num = *(int *) argv[1];
  idl_s = (IDL_STRING *) argv[2];
  Snapbase = idl_s->s;

  NFiles = (int *) argv[3];

  sprintf(buf, "%s/%s_%03d.0", OutputDir, Snapbase, Num);
  if(!(fd = fopen(buf, "r")))
    {
      printf("can't open file `%s'\n", buf);
      return -1;
    }

  fread(&dummy, sizeof(int), 1, fd);
  printf("dummy=%d\n", dummy);

  fread(&header, sizeof(io_header), 1, fd);
  fread(&dummy, sizeof(int), 1, fd);

  printf("dummy=%d\n", dummy);
  fclose(fd);

  *NFiles = header.num_files;

  return header.hashtabsize;
}


int get_hash_table(int argc, void *argv[])
{
  int Num, dummy, filenr, NTask;
  int i, firstcell, lastcell;
  io_header header;
  IDL_STRING *idl_s;
  char *OutputDir, *Snapbase;
  char buf[1000];
  FILE *fd;
  int *Hashtable;
  int *Filetable;
  int *LastHashCell;
  int *NInFiles;

  idl_s = (IDL_STRING *) argv[0];
  OutputDir = idl_s->s;
  Num = *(int *) argv[1];
  idl_s = (IDL_STRING *) argv[2];
  Snapbase = idl_s->s;

  Hashtable = (int *) argv[3];
  Filetable = (int *) argv[4];
  LastHashCell = (int *) argv[5];
  NInFiles = (int *) argv[6];

  NTask = 1;			/* will be taken from header */

  for(filenr = 0; filenr < NTask; filenr++)
    {
      sprintf(buf, "%s/%s_%03d.%d", OutputDir, Snapbase, Num, filenr);
      if(!(fd = fopen(buf, "r")))
	{
	  printf("can't open file `%s'\n", buf);
	  return -1;
	}
      fread(&dummy, sizeof(int), 1, fd);
      fread(&header, sizeof(io_header), 1, fd);
      fread(&dummy, sizeof(int), 1, fd);
      NTask = header.num_files;

      /* skip positions */
      fread(&dummy, sizeof(int), 1, fd);
      fseek(fd, dummy, SEEK_CUR);
      fread(&dummy, sizeof(int), 1, fd);

      /* skip velocities */
      fread(&dummy, sizeof(int), 1, fd);
      fseek(fd, dummy, SEEK_CUR);
      fread(&dummy, sizeof(int), 1, fd);

      /* skip IDs */
      fread(&dummy, sizeof(int), 1, fd);
      fseek(fd, dummy, SEEK_CUR);
      fread(&dummy, sizeof(int), 1, fd);

      fread(&dummy, sizeof(int), 1, fd);
      fread(&firstcell, sizeof(int), 1, fd);
      fread(&lastcell, sizeof(int), 1, fd);
      fread(&dummy, sizeof(int), 1, fd);

      LastHashCell[filenr] = lastcell;
      NInFiles[filenr] = header.npart[1];

      if(firstcell < 0 || firstcell >= header.hashtabsize || lastcell < 0 || lastcell >= header.hashtabsize)
	{
	  printf("bummer!\n");
	  return -1;
	}

      fread(&dummy, sizeof(int), 1, fd);
      fread(&Hashtable[firstcell], sizeof(int), lastcell - firstcell + 1, fd);
      fread(&dummy, sizeof(int), 1, fd);

      for(i = 0; i < lastcell - firstcell + 1; i++)
	Filetable[firstcell + i] = filenr;

      fclose(fd);
    }

  return 0;
}



/* determines the number of particles that would be 
 * in each file in case and equal volume decomposition is
 * performed.
 */
int get_particles_in_cubes(int argc, void *argv[])
{
  int Num;
  IDL_STRING *idl_s;
  char *OutputDir, *Snapbase;
  int *Hashtable, *LastHashCell;
  int *Filetable, *NInFiles;
  int NFiles;
  int hashtabsize, count;
  int hash_key, countsum, *TabCount, proc;


  idl_s = (IDL_STRING *) argv[0];
  OutputDir = idl_s->s;
  Num = *(int *) argv[1];
  idl_s = (IDL_STRING *) argv[2];
  Snapbase = idl_s->s;

  Hashtable = (int *) argv[3];
  Filetable = (int *) argv[4];
  hashtabsize = *(int *) argv[5];
  LastHashCell = (int *) argv[6];
  NInFiles = (int *) argv[7];
  NFiles =   *(int *) argv[8];
  TabCount = (int *) argv[9];


  for(proc=0; proc < NFiles; proc++)
    {
      countsum=0;
      for(hash_key = proc*(hashtabsize/NFiles); hash_key < (proc+1)*(hashtabsize/NFiles); hash_key++)
	{
	  if(hash_key != LastHashCell[Filetable[hash_key]])
	    count = Hashtable[hash_key + 1] - Hashtable[hash_key];
	  else
	    count = NInFiles[Filetable[hash_key]] - Hashtable[hash_key];

	  countsum+=count;
	}

      TabCount[proc] = countsum;
    }
  
  return 0;
}




int get_group_coordinates(int argc, void *argv[])
{
  int Num, dummy, NTask, ind;
  int i, j, n;
  io_header header;
  IDL_STRING *idl_s;
  char *OutputDir, *Snapbase;
  char buf[1000];
  FILE *fd;
  int *Hashtable, *LastHashCell;
  int *Filetable;
  int *NInFiles;
  int hashtabsize, GroupNr, FileNr, GroupLen, Ngroups, TotNgroups, count, Nids;
  int len, offset;
  float *Pos;
  float *Sx, *Sy, *Sz;
  double sx, sy, sz;
  double refx, refy, refz;
  float *pos_read;
  int hash_key;
  unsigned long long id;
  unsigned long long *ids, *id_read;

  idl_s = (IDL_STRING *) argv[0];
  OutputDir = idl_s->s;
  Num = *(int *) argv[1];
  idl_s = (IDL_STRING *) argv[2];
  Snapbase = idl_s->s;

  Hashtable = (int *) argv[3];
  Filetable = (int *) argv[4];
  hashtabsize = *(int *) argv[5];
  LastHashCell = (int *) argv[6];
  NInFiles = (int *) argv[7];
  GroupNr = *(int *) argv[8];
  FileNr = *(int *) argv[9];
  GroupLen = *(int *) argv[10];
  Pos = (float *) argv[11];
  Sx = (float *) argv[12];
  Sy = (float *) argv[13];
  Sz = (float *) argv[14];

  sprintf(buf, "%s/group_tab_%03d.%d", OutputDir, Num, FileNr);
  if(!(fd = fopen(buf, "r")))
    {
      printf("can't open file `%s'\n", buf);
      return -1;
    }

  fread(&Ngroups, sizeof(int), 1, fd);
  fread(&Nids, sizeof(int), 1, fd);
  fread(&TotNgroups, sizeof(int), 1, fd);
  fread(&NTask, sizeof(int), 1, fd);
  /* skip group-len table */
  fseek(fd, sizeof(int) * Ngroups, SEEK_CUR);
  fseek(fd, sizeof(int) * GroupNr, SEEK_CUR);
  fread(&offset, sizeof(int), 1, fd);
  fclose(fd);

  ids = malloc(GroupLen * sizeof(long long));

  sprintf(buf, "%s/group_ids_%03d.%d", OutputDir, Num, FileNr);
  if(!(fd = fopen(buf, "r")))
    {
      printf("can't open file `%s'\n", buf);
      return -1;
    }
  fread(&Ngroups, sizeof(int), 1, fd);
  fread(&Nids, sizeof(int), 1, fd);
  fread(&TotNgroups, sizeof(int), 1, fd);
  fread(&NTask, sizeof(int), 1, fd);

  fseek(fd, sizeof(long long) * offset, SEEK_CUR);
  fread(ids, sizeof(long long), GroupLen, fd);
  fclose(fd);

  for(i = 0; i < hashtabsize; i++)
    Filetable[i] <<= 1;


  for(i = 0, count = 0; i < GroupLen; i++)
    {
      hash_key = (ids[i] >> 34);

      if(hash_key >= hashtabsize)
	{
	  printf("bummer\n");
	  return -1;
	}

      if((Filetable[hash_key] & 1) == 0)
	{
	  Filetable[hash_key] |= 1;

	  if(hash_key != LastHashCell[Filetable[hash_key] >> 1])
	    count += Hashtable[hash_key + 1] - Hashtable[hash_key];
	  else
	    count += NInFiles[Filetable[hash_key] >> 1] - Hashtable[hash_key];
	}
    }

  pos_read = malloc(3 * count * sizeof(float));
  id_read = malloc(count * sizeof(long long));

  for(i = 0, count = 0; i < hashtabsize; i++)
    {
      if((Filetable[i] & 1))
	{
	  sprintf(buf, "%s/%s_%03d.%d", OutputDir, Snapbase, Num, Filetable[i] >> 1);
	  if(!(fd = fopen(buf, "r")))
	    {
	      printf("can't open file `%s'\n", buf);
	      return -1;
	    }
	  fread(&dummy, sizeof(int), 1, fd);
	  fread(&header, sizeof(io_header), 1, fd);
	  fread(&dummy, sizeof(int), 1, fd);

	  BoxSize = header.BoxSize;

	  fread(&dummy, sizeof(int), 1, fd);
	  fseek(fd, 3 * Hashtable[i] * sizeof(float), SEEK_CUR);

	  if(i != LastHashCell[Filetable[i] >> 1])
	    len = Hashtable[i + 1] - Hashtable[i];
	  else
	    len = NInFiles[Filetable[i] >> 1] - Hashtable[i];

	  fread(&pos_read[3 * count], sizeof(float), 3 * len, fd);

	  count += len;
	  fclose(fd);
	}
    }


  for(i = 0, count = 0; i < hashtabsize; i++)
    {
      if((Filetable[i] & 1))
	{
	  sprintf(buf, "%s/%s_%03d.%d", OutputDir, Snapbase, Num, Filetable[i] >> 1);
	  if(!(fd = fopen(buf, "r")))
	    {
	      printf("can't open file `%s'\n", buf);
	      return -1;
	    }
	  fread(&dummy, sizeof(int), 1, fd);
	  fread(&header, sizeof(io_header), 1, fd);
	  fread(&dummy, sizeof(int), 1, fd);

	  /* skip positions */
	  fread(&dummy, sizeof(int), 1, fd);
	  fseek(fd, dummy, SEEK_CUR);
	  fread(&dummy, sizeof(int), 1, fd);

	  /* skip velocities */
	  fread(&dummy, sizeof(int), 1, fd);
	  fseek(fd, dummy, SEEK_CUR);
	  fread(&dummy, sizeof(int), 1, fd);

	  fread(&dummy, sizeof(int), 1, fd);
	  fseek(fd, Hashtable[i] * sizeof(long long), SEEK_CUR);

	  if(i != LastHashCell[Filetable[i] >> 1])
	    len = Hashtable[i + 1] - Hashtable[i];
	  else
	    len = NInFiles[Filetable[i] >> 1] - Hashtable[i];

	  fread(&id_read[count], sizeof(long long), len, fd);

	  count += len;
	  fclose(fd);
	}
    }

  for(i = 0; i < GroupLen; i++)
    ids[i] &= ((((long long) 1) << 34) - 1);

  for(i = 0; i < count; i++)
    id_read[i] = ((id_read[i] & ((((long long) 1) << 34) - 1)) << 29) + i;

  qsort(ids, GroupLen, sizeof(long long), id_sort_compare_key);
  qsort(id_read, count, sizeof(long long), id_sort_compare_key);

  if(count < GroupLen)
    {
      printf("PROBLEM! count=%d GroupLen=%d\n", count, GroupLen);
      printf("Something seems to be wrong here=!\n");
    }

  for(i = 0, n = 0; i < GroupLen && n < count; i++)
    {
      id = (id_read[n] >> 29);

      while(n < count && id < ids[i])
	{
	  n++;
	  id = (id_read[n] >> 29);
	}

      if(id != ids[i])
	{
	  printf("We have a mismatch! (i=%d) something is wrong here.\n", i);
	}

      ind = (id_read[n] & ((1 << 29) - 1));

      for(j = 0; j < 3; j++)
	Pos[i * 3 + j] = pos_read[ind * 3 + j];
    }

  sx = sy = sz = 0;
  refx = Pos[0];
  refy = Pos[1];
  refz = Pos[2];

  for(i = 0; i < GroupLen; i++)
    {
      Pos[i * 3 + 0] = fof_periodic(Pos[i * 3 + 0] - refx);
      Pos[i * 3 + 1] = fof_periodic(Pos[i * 3 + 1] - refy);
      Pos[i * 3 + 2] = fof_periodic(Pos[i * 3 + 2] - refz);
    }

  for(i = 0; i < GroupLen; i++)
    {
      sx += Pos[i * 3 + 0];
      sy += Pos[i * 3 + 1];
      sz += Pos[i * 3 + 2];
    }

  sx /= GroupLen;
  sy /= GroupLen;
  sz /= GroupLen;

  for(i = 0; i < GroupLen; i++)
    {
      Pos[i * 3 + 0] -= sx;
      Pos[i * 3 + 1] -= sy;
      Pos[i * 3 + 2] -= sz;
    }

  for(i = 0; i < hashtabsize; i++)
    Filetable[i] >>= 1;

  free(id_read);
  free(pos_read);
  free(ids);


  *Sx = fof_periodic_wrap(sx + refx);
  *Sy = fof_periodic_wrap(sy + refy);
  *Sz = fof_periodic_wrap(sz + refz);

  return 0;
}


double fof_periodic_wrap(double x)
{
  while(x >= BoxSize)
    x -= BoxSize;

  while(x < 0)
    x += BoxSize;

  return x;
}


double fof_periodic(double x)
{
  if(x >= 0.5 * BoxSize)
    x -= BoxSize;

  if(x < -0.5 * BoxSize)
    x += BoxSize;

  return x;
}


int id_sort_compare_key(const void *a, const void *b)
{
  if(*((long long *) a) < *((long long *) b))
    return -1;

  if(*((long long *) a) > *((long long *) b))
    return +1;

  return 0;
}



int get_spherical_region_count(int argc, void *argv[])
{
  int Num, dummy;
  io_header header;
  IDL_STRING *idl_s;
  char *OutputDir, *Snapbase;
  char buf[1000];
  FILE *fd;
  int *Hashtable, *LastHashCell;
  int *Filetable;
  int *NInFiles;
  int hashtabsize, count;
  float Sx, Sy, Sz, Rad;
  int hash_key;
  double cellsize;
  int cells, cx, cy, cz, ix, iy, iz, iix, iiy, iiz, base, hashbits;

  idl_s = (IDL_STRING *) argv[0];
  OutputDir = idl_s->s;
  Num = *(int *) argv[1];
  idl_s = (IDL_STRING *) argv[2];
  Snapbase = idl_s->s;

  Hashtable = (int *) argv[3];
  Filetable = (int *) argv[4];
  hashtabsize = *(int *) argv[5];
  LastHashCell = (int *) argv[6];
  NInFiles = (int *) argv[7];
  Sx = *(float *) argv[8];
  Sy = *(float *) argv[9];
  Sz = *(float *) argv[10];
  Rad = *(float *) argv[11];


  sprintf(buf, "%s/%s_%03d.%d", OutputDir, Snapbase, Num, 0);
  if(!(fd = fopen(buf, "r")))
    {
      printf("can't open file `%s'\n", buf);
      return -1;
    }
  fread(&dummy, sizeof(int), 1, fd);
  fread(&header, sizeof(io_header), 1, fd);
  fread(&dummy, sizeof(int), 1, fd);
  fclose(fd);

  BoxSize = header.BoxSize;

 
  base = 1;
  while(base * base * base < hashtabsize)
    base *= 2;

  hashbits = 1;
  while((1 << hashbits) < base)
    hashbits++;

  cellsize = BoxSize / base;

  cells = Rad/cellsize + 1; 
  cx = Sx/cellsize;
  cy = Sy/cellsize;
  cz = Sz/cellsize;


  count = 0;

  for(ix = cx - cells; ix <= cx + cells; ix++)
    for(iy = cy - cells; iy <= cy + cells; iy++)
      for(iz = cz - cells; iz <= cz + cells; iz++)
	{
	  iix = ix;
	  iiy = iy;
	  iiz = iz;

	  if(iix<0)
	    iix += base;
	  if(iix>=base)
	    iix -= base;

	  if(iiy<0)
	    iiy += base;
	  if(iiy>=base)
	    iiy -= base;

	  if(iiz<0)
	    iiz += base;
	  if(iiz>=base)
	    iiz -= base;

	  hash_key = peano_hilbert_key(iix, iiy, iiz, hashbits);

	  if(hash_key != LastHashCell[Filetable[hash_key]])
	    count += Hashtable[hash_key + 1] - Hashtable[hash_key];
	  else
	    count += NInFiles[Filetable[hash_key]] - Hashtable[hash_key];
	}

  return count;
}



int get_spherical_region_coordinates(int argc, void *argv[])
{
  int Num, dummy;
  int i;
  io_header header;
  IDL_STRING *idl_s;
  char *OutputDir, *Snapbase;
  char buf[1000];
  FILE *fd;
  int *Hashtable, *LastHashCell;
  int *Filetable;
  int *NInFiles;
  int hashtabsize, count;
  int len;
  float *Pos;
  float Sx, Sy, Sz, Rad;
  double cellsize;
  int cells, cx, cy, cz, ix, iy, iz, iix, iiy, iiz, base, hashbits, hashkey;
  

  idl_s = (IDL_STRING *) argv[0];
  OutputDir = idl_s->s;
  Num = *(int *) argv[1];
  idl_s = (IDL_STRING *) argv[2];
  Snapbase = idl_s->s;

  Hashtable = (int *) argv[3];
  Filetable = (int *) argv[4];
  hashtabsize = *(int *) argv[5];
  LastHashCell = (int *) argv[6];
  NInFiles = (int *) argv[7];
  Sx = *(float *) argv[8];
  Sy = *(float *) argv[9];
  Sz = *(float *) argv[10];
  Rad = *(float *) argv[11];
  Pos = (float *) argv[12];



  sprintf(buf, "%s/%s_%03d.%d", OutputDir, Snapbase, Num, 0);
  if(!(fd = fopen(buf, "r")))
    {
      printf("can't open file `%s'\n", buf);
      return -1;
    }
  fread(&dummy, sizeof(int), 1, fd);
  fread(&header, sizeof(io_header), 1, fd);
  fread(&dummy, sizeof(int), 1, fd);
  fclose(fd);

  BoxSize = header.BoxSize;



  base = 1;
  while(base * base * base < hashtabsize)
    base *= 2;

  hashbits = 1;
  while((1 << hashbits) < base)
    hashbits++;

  cellsize = BoxSize / base;

  cells = Rad/cellsize + 1; 
  cx = Sx/cellsize;
  cy = Sy/cellsize;
  cz = Sz/cellsize;
  

  count = 0;

  for(ix = cx - cells; ix <= cx + cells; ix++)
    for(iy = cy - cells; iy <= cy + cells; iy++)
      for(iz = cz - cells; iz <= cz + cells; iz++)
	{
	  iix = ix;
	  iiy = iy;
	  iiz = iz;

	  if(iix<0)
	    iix += base;
	  if(iix>=base)
	    iix -= base;

	  if(iiy<0)
	    iiy += base;
	  if(iiy>=base)
	    iiy -= base;

	  if(iiz<0)
	    iiz += base;
	  if(iiz>=base)
	    iiz -= base;

	  hashkey = peano_hilbert_key(iix, iiy, iiz, hashbits);

	  sprintf(buf, "%s/%s_%03d.%d", OutputDir, Snapbase, Num, Filetable[hashkey]);
	  if(!(fd = fopen(buf, "r")))
	    {
	      printf("can't open file `%s'\n", buf);
	      return -1;
	    }
	  fread(&dummy, sizeof(int), 1, fd);
	  fread(&header, sizeof(io_header), 1, fd);
	  fread(&dummy, sizeof(int), 1, fd);

	  BoxSize = header.BoxSize;

	  fread(&dummy, sizeof(int), 1, fd);
	  fseek(fd, 3 * Hashtable[hashkey] * sizeof(float), SEEK_CUR);

	  if(hashkey != LastHashCell[Filetable[hashkey]])
	    len = Hashtable[hashkey + 1] - Hashtable[hashkey];
	  else
	    len = NInFiles[Filetable[hashkey]] - Hashtable[hashkey];

	  fread(&Pos[3 * count], sizeof(float), 3 * len, fd);

	  count += len;
	  fclose(fd);
	}



  for(i = 0; i < count; i++)
    {
      Pos[i * 3 + 0] = fof_periodic(Pos[i * 3 + 0] - Sx);
      Pos[i * 3 + 1] = fof_periodic(Pos[i * 3 + 1] - Sy);
      Pos[i * 3 + 2] = fof_periodic(Pos[i * 3 + 2] - Sz);
    }

  return 0;
}























static int quadrants[24][2][2][2] = {
  /* rotx=0, roty=0-3 */
  {{{0, 7}, {1, 6}}, {{3, 4}, {2, 5}}},
  {{{7, 4}, {6, 5}}, {{0, 3}, {1, 2}}},
  {{{4, 3}, {5, 2}}, {{7, 0}, {6, 1}}},
  {{{3, 0}, {2, 1}}, {{4, 7}, {5, 6}}},
  /* rotx=1, roty=0-3 */
  {{{1, 0}, {6, 7}}, {{2, 3}, {5, 4}}},
  {{{0, 3}, {7, 4}}, {{1, 2}, {6, 5}}},
  {{{3, 2}, {4, 5}}, {{0, 1}, {7, 6}}},
  {{{2, 1}, {5, 6}}, {{3, 0}, {4, 7}}},
  /* rotx=2, roty=0-3 */
  {{{6, 1}, {7, 0}}, {{5, 2}, {4, 3}}},
  {{{1, 2}, {0, 3}}, {{6, 5}, {7, 4}}},
  {{{2, 5}, {3, 4}}, {{1, 6}, {0, 7}}},
  {{{5, 6}, {4, 7}}, {{2, 1}, {3, 0}}},
  /* rotx=3, roty=0-3 */
  {{{7, 6}, {0, 1}}, {{4, 5}, {3, 2}}},
  {{{6, 5}, {1, 2}}, {{7, 4}, {0, 3}}},
  {{{5, 4}, {2, 3}}, {{6, 7}, {1, 0}}},
  {{{4, 7}, {3, 0}}, {{5, 6}, {2, 1}}},
  /* rotx=4, roty=0-3 */
  {{{6, 7}, {5, 4}}, {{1, 0}, {2, 3}}},
  {{{7, 0}, {4, 3}}, {{6, 1}, {5, 2}}},
  {{{0, 1}, {3, 2}}, {{7, 6}, {4, 5}}},
  {{{1, 6}, {2, 5}}, {{0, 7}, {3, 4}}},
  /* rotx=5, roty=0-3 */
  {{{2, 3}, {1, 0}}, {{5, 4}, {6, 7}}},
  {{{3, 4}, {0, 7}}, {{2, 5}, {1, 6}}},
  {{{4, 5}, {7, 6}}, {{3, 2}, {0, 1}}},
  {{{5, 2}, {6, 1}}, {{4, 3}, {7, 0}}}
};


static int rotxmap_table[24] = { 4, 5, 6, 7, 8, 9, 10, 11,
  12, 13, 14, 15, 0, 1, 2, 3, 17, 18, 19, 16, 23, 20, 21, 22
};

static int rotymap_table[24] = { 1, 2, 3, 0, 16, 17, 18, 19,
  11, 8, 9, 10, 22, 23, 20, 21, 14, 15, 12, 13, 4, 5, 6, 7
};

static int rotx_table[8] = { 3, 0, 0, 2, 2, 0, 0, 1 };
static int roty_table[8] = { 0, 1, 1, 2, 2, 3, 3, 0 };

static int sense_table[8] = { -1, -1, -1, +1, +1, -1, -1, -1 };

static int flag_quadrants_inverse = 1;
static char quadrants_inverse_x[24][8];
static char quadrants_inverse_y[24][8];
static char quadrants_inverse_z[24][8];


/*! This function computes a Peano-Hilbert key for an integer triplet (x,y,z),
 *  with x,y,z in the range between 0 and 2^bits-1.
 */
peanokey peano_hilbert_key(int x, int y, int z, int bits)
{
  int i, quad, bitx, bity, bitz;
  int mask, rotation, rotx, roty, sense;
  peanokey key;


  mask = 1 << (bits - 1);
  key = 0;
  rotation = 0;
  sense = 1;


  for(i = 0; i < bits; i++, mask >>= 1)
    {
      bitx = (x & mask) ? 1 : 0;
      bity = (y & mask) ? 1 : 0;
      bitz = (z & mask) ? 1 : 0;

      quad = quadrants[rotation][bitx][bity][bitz];

      key <<= 3;
      key += (sense == 1) ? (quad) : (7 - quad);

      rotx = rotx_table[quad];
      roty = roty_table[quad];
      sense *= sense_table[quad];

      while(rotx > 0)
	{
	  rotation = rotxmap_table[rotation];
	  rotx--;
	}

      while(roty > 0)
	{
	  rotation = rotymap_table[rotation];
	  roty--;
	}
    }

  return key;
}


/*! This function computes for a given Peano-Hilbert key, the inverse,
 *  i.e. the integer triplet (x,y,z) with a Peano-Hilbert key equal to the
 *  input key. (This functionality is actually not needed in the present
 *  code.)
 */
void peano_hilbert_key_inverse(peanokey key, int bits, int *x, int *y, int *z)
{
  int i, keypart, bitx, bity, bitz, mask, quad, rotation, shift;
  char sense, rotx, roty;

  if(flag_quadrants_inverse)
    {
      flag_quadrants_inverse = 0;
      for(rotation = 0; rotation < 24; rotation++)
        for(bitx = 0; bitx < 2; bitx++)
          for(bity = 0; bity < 2; bity++)
            for(bitz = 0; bitz < 2; bitz++)
              {
                quad = quadrants[rotation][bitx][bity][bitz];
                quadrants_inverse_x[rotation][quad] = bitx;
                quadrants_inverse_y[rotation][quad] = bity;
                quadrants_inverse_z[rotation][quad] = bitz;
              }
    }

  shift = 3 * (bits - 1);
  mask = 7 << shift;

  rotation = 0;
  sense = 1;

  *x = *y = *z = 0;

  for(i = 0; i < bits; i++, mask >>= 3, shift -= 3)
    {
      keypart = (key & mask) >> shift;

      quad = (sense == 1) ? (keypart) : (7 - keypart);

      *x = (*x << 1) + quadrants_inverse_x[rotation][quad];
      *y = (*y << 1) + quadrants_inverse_y[rotation][quad];
      *z = (*z << 1) + quadrants_inverse_z[rotation][quad];

      rotx = rotx_table[quad];
      roty = roty_table[quad];
      sense *= sense_table[quad];

      while(rotx > 0)
        {
          rotation = rotxmap_table[rotation];
          rotx--;
        }

      while(roty > 0)
        {
          rotation = rotymap_table[rotation];
          roty--;
        }
    }
}

